<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Faceting Studio - Trevor Hannam & v2.1 Hybrid</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #eaddca; font-family: 'serif'; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 10; cursor: grab; }
        #canvas-container:active { cursor: grabbing; }
        
        #newspaper-bg {
            position: absolute;
            top: 0; left: 0; width: 100vw; height: 100vh;
            padding: 50px; color: #1a1a1a; user-select: none;
            background: #eaddca; overflow: hidden;
            display: grid; grid-template-columns: 1fr 1fr; gap: 40px; z-index: 1;
        }
        .column { text-align: justify; line-height: 1.6; font-size: 18px; }
        h1 { grid-column: span 2; font-size: 80px; font-weight: 900; text-align: center; border-bottom: 4px solid #1a1a1a; margin-bottom: 20px; text-transform: uppercase; }
        
        /* GUI Panel */
        .controls-panel {
            position: absolute;
            top: 20px; right: 20px;
            width: 280px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 24px;
            color: #1a1a1a;
            z-index: 30;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            font-family: sans-serif;
        }
        .control-group { margin-bottom: 20px; }
        .control-label { display: block; font-size: 11px; font-weight: 800; text-transform: uppercase; margin-bottom: 8px; letter-spacing: 0.1em; opacity: 0.7; }
        input[type="range"] { width: 100%; accent-color: #1a1a1a; cursor: pointer; }
        select, input[type="color"] { 
            width: 100%; background: rgba(255,255,255,0.5); border: 1px solid rgba(0,0,0,0.1); 
            border-radius: 8px; padding: 8px; font-size: 14px; outline: none;
        }
        .ui-overlay {
            position: absolute; bottom: 30px; left: 30px;
            background: rgba(0,0,0,0.85); padding: 12px 24px; border-radius: 50px;
            color: white; z-index: 20; font-family: sans-serif; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="newspaper-bg">
        <h1>Gemstone Masterpiece</h1>
        <div class="column">
            <p><b>REFRACTION EVOLVED.</b> Using Trevor Hannam's professional faceting techniques, we have reconstructed this gemstone with precise 1:2 height ratios between the crown and pavilion. This ensures that the light interaction is a result of professional geometry. The Window (Table) is perfectly aligned to capture the maximum amount of environmental data.</p>
            <p>Every single ray of light is calculated to provide a realistic magnification effect. When you drag the gemstone across these words, you will notice how the typography distorts, enlarges, and splits into spectral colors. This confirms the quality of the "Standard Brilliant" cut.</p>
        </div>
        <div class="column">
            <p><b>STUDIO BRILLIANCE.</b> Scintillation—the blinding flashes of light—is enhanced by sharpening the specular focal points. Natural diamonds and high-lead glass share this property. As the facets align with your view, the displacement map shifts, creating a shimmering effect that is both mathematically precise and visually mesmerizing.</p>
            <p>Select iconic shapes like the Emerald or Pear cut. Each shape respects the physical constraints of traditional lapidary arts while maintaining the high-performance optical simulation you prefer.</p>
        </div>
    </div>

    <!-- 커스텀 컨트롤러 패널 -->
    <div class="controls-panel">
        <div class="control-group">
            <label class="control-label">세공 모양 (Professional Cut)</label>
            <select id="shape-select">
                <option value="brilliant">라운드 브릴리언트 (Brilliant)</option>
                <option value="emerald">에메랄드 컷 (Emerald)</option>
                <option value="princess">프린세스 컷 (Princess)</option>
                <option value="pear">페어 컷 (Pear/물방울)</option>
                <option value="oval">오벌 컷 (Oval/타원)</option>
            </select>
        </div>

        <div class="control-group">
            <label class="control-label">세공 정교함 (Cut Detail)</label>
            <input type="range" id="detail-range" min="0" max="6" step="1" value="3">
        </div>

        <div class="control-group">
            <label class="control-label">보석 색상 (Gem Color)</label>
            <input type="color" id="color-picker" value="#ffffff">
        </div>

        <!-- 탁도 조절 슬라이더 추가 -->
        <div class="control-group">
            <label class="control-label">보석 탁도 (Turbidity)</label>
            <input type="range" id="turbidity-range" min="0" max="1" step="0.05" value="0">
        </div>
        
        <p class="text-[9px] opacity-40 leading-tight">연구 반영: 1:2 세공 비율 적용됨.<br>v2.1 광학 엔진 & 탁도 컨트롤 적용 중.</p>
    </div>

    <div id="canvas-container"></div>

    <div class="ui-overlay">
        <p class="text-xs uppercase tracking-widest font-bold">Professional Gem Studio | Scintillation+ & Turbidity</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        let scene, camera, renderer, gemstone, controls;
        let bgTexture;

        let isDragging = false;
        let rotationVelocity = 0.008;
        let previousMouseX = 0;
        const damping = 0.96;
        const baseAutoRotation = 0.003;

        const FIXED_THICKNESS = 1.5;
        const FIXED_DISPERSION = 0.05;

        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3; 
            
            const container = document.getElementById('canvas-container');
            container.appendChild(renderer.domElement);
            container.style.pointerEvents = 'auto';

            const bgElement = document.getElementById('newspaper-bg');
            try {
                const canvas = await window.html2canvas(bgElement, { scale: 1.2 });
                bgTexture = new THREE.CanvasTexture(canvas);
                bgTexture.minFilter = THREE.LinearFilter;
                bgTexture.magFilter = THREE.LinearFilter;
            } catch (e) { console.error(e); }

            createGemstone();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            setupUIListeners();
            setupInertiaEvents(container);

            animate();
        }

        function createGemstone() {
            if (gemstone) {
                scene.remove(gemstone);
                gemstone.geometry.dispose();
            }

            const shape = document.getElementById('shape-select').value;
            const uiDetail = parseInt(document.getElementById('detail-range').value);
            const detail = uiDetail - 3; 
            const color = new THREE.Color(document.getElementById('color-picker').value);
            const turbidity = parseFloat(document.getElementById('turbidity-range').value);
            
            let geometry;
            const h = 1.6; 
            const cH = h * 0.33; 
            const pH = h * 0.67;

            switch(shape) {
                case 'emerald': 
                    const eG = new THREE.CylinderGeometry(0.8, 0.82, 0.05, Math.max(4, 8 + detail * 2)); 
                    const eC = new THREE.CylinderGeometry(0.6, 0.8, cH, Math.max(4, 8 + detail * 2), Math.max(1, detail + 1));
                    const eP = new THREE.CylinderGeometry(0.82, 0.1, pH, Math.max(4, 8 + detail * 2), Math.max(1, detail + 1));
                    eC.translate(0, cH/2 + 0.025, 0); eP.translate(0, -pH/2 - 0.025, 0);
                    geometry = BufferGeometryUtils.mergeGeometries([eG, eC, eP]);
                    geometry.scale(1.2, 1, 0.9);
                    break;
                case 'princess': 
                    const pG = new THREE.BoxGeometry(1.15, 0.05, 1.15);
                    const pC = new THREE.CylinderGeometry(0.8, 1.15, cH, 4, Math.max(1, detail + 1));
                    const pP = new THREE.CylinderGeometry(1.15, 0.01, pH, 4, Math.max(1, detail + 1));
                    pC.translate(0, cH/2 + 0.025, 0); pC.rotateY(Math.PI/4);
                    pP.translate(0, -pH/2 - 0.025, 0); pP.rotateY(Math.PI/4);
                    geometry = BufferGeometryUtils.mergeGeometries([pG, pC, pP]);
                    break;
                case 'pear': 
                    geometry = new THREE.SphereGeometry(1, Math.max(6, 14 + detail * 6), Math.max(4, 12 + detail * 6));
                    const posP = geometry.attributes.position;
                    for (let i = 0; i < posP.count; i++) {
                        let x = posP.getX(i); let y = posP.getY(i); let z = posP.getZ(i);
                        if (y > 0) { 
                            let f = 1.0 - (y * 0.7);
                            posP.setX(i, x * f); posP.setZ(i, z * f); posP.setY(i, y * 0.8);
                        } else { posP.setY(i, y * 1.5); }
                        posP.setZ(i, posP.getZ(i) + (Math.pow(y + 1, 2) * 0.12));
                    }
                    break;
                case 'oval': 
                    geometry = new THREE.SphereGeometry(1, Math.max(6, 16 + detail * 8), Math.max(4, 12 + detail * 6));
                    geometry.scale(0.85, 1.35, 0.85);
                    break;
                default: 
                    if (detail === -3) {
                        geometry = new THREE.TetrahedronGeometry(1.2);
                    } else if (detail === -2) {
                        geometry = new THREE.OctahedronGeometry(1.2);
                    } else if (detail === -1) {
                        geometry = new THREE.DodecahedronGeometry(1.2);
                    } else {
                        const bG = new THREE.CylinderGeometry(1.0, 1.0, 0.05, 16 + detail * 8); 
                        const bC = new THREE.CylinderGeometry(0.65, 1.0, cH, 16 + detail * 8); 
                        const bP = new THREE.CylinderGeometry(1.0, 0.01, pH, 16 + detail * 8);
                        bC.translate(0, cH/2 + 0.025, 0); bP.translate(0, -pH/2 - 0.025, 0);
                        geometry = BufferGeometryUtils.mergeGeometries([bG, bC, bP]);
                    }
            }

            geometry = geometry.toNonIndexed();
            geometry.computeVertexNormals();

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    tBackground: { value: bgTexture },
                    uColor: { value: color },
                    uThickness: { value: FIXED_THICKNESS },
                    uDispersion: { value: FIXED_DISPERSION },
                    uTurbidity: { value: turbidity },
                    uTime: { value: 0 },
                    uLightPos: { value: new THREE.Vector3(5, 5, 5) }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vEye;
                    varying vec4 vScreenPos;
                    varying vec3 vLocalPos;
                    void main() {
                        vLocalPos = position;
                        vNormal = normalize(normalMatrix * normal);
                        vec4 worldPos = modelMatrix * vec4(position, 1.0);
                        vEye = normalize(worldPos.xyz - cameraPosition);
                        vScreenPos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        gl_Position = vScreenPos;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tBackground;
                    uniform vec3 uColor;
                    uniform float uThickness;
                    uniform float uDispersion;
                    uniform float uTurbidity;
                    uniform float uTime;
                    uniform vec3 uLightPos;
                    varying vec3 vNormal;
                    varying vec3 vEye;
                    varying vec4 vScreenPos;
                    varying vec3 vLocalPos;

                    float smoothStepFunc(float a, float b, float t) {
                        t = clamp((t - a) / (b - a), 0.0, 1.0);
                        return t * t * (3.0 - 2.0 * t);
                    }

                    void main() {
                        vec2 uv = (vScreenPos.xy / vScreenPos.w) * 0.5 + 0.5;
                        float dist = length(vLocalPos.xy);
                        float displacementStrength = smoothStepFunc(1.5, 0.0, dist);
                        
                        vec3 refractVec = refract(vEye, vNormal, 1.0 / 2.41);
                        vec2 refractOffset = refractVec.xy * 0.15 * uThickness * displacementStrength;
                        
                        float r = texture2D(tBackground, uv + refractOffset * (1.0 + uDispersion)).r;
                        float g = texture2D(tBackground, uv + refractOffset).g;
                        float b = texture2D(tBackground, uv + refractOffset * (1.0 - uDispersion)).b;
                        
                        vec3 baseColor = vec3(r, g, b) * uColor * 1.1;

                        // --- 탁도(Turbidity) 반영 로직 ---
                        // 탁도가 높을수록 우유빛 컬러(Off-white)와 혼합하여 내부 산란 재현
                        vec3 milkyTone = vec3(0.92, 0.92, 0.95);
                        baseColor = mix(baseColor, milkyTone, uTurbidity * 0.7);
                        
                        vec3 lightDir = normalize(uLightPos);
                        vec3 halfDir = normalize(lightDir - vEye);
                        float shadowMask = max(dot(vNormal, lightDir), 0.6);
                        baseColor *= (0.8 + 0.2 * shadowMask);

                        // 하이라이트(스펙큘러)는 탁도에 상관없이 표면 질감을 유지하기 위해 마지막에 합성
                        float spec = pow(max(dot(vNormal, halfDir), 0.0), 256.0); 
                        baseColor = mix(baseColor, vec3(1.2), spec * 0.65); 

                        float fresnel = pow(1.0 - max(dot(vNormal, -vEye), 0.0), 3.0);
                        baseColor += vec3(0.12, 0.18, 0.25) * fresnel * 0.4;

                        gl_FragColor = vec4(baseColor, 1.0);
                    }
                `,
                transparent: true
            });

            gemstone = new THREE.Mesh(geometry, material);
            scene.add(gemstone);
        }

        function setupUIListeners() {
            const updateAction = () => createGemstone();
            document.getElementById('shape-select').addEventListener('change', updateAction);
            document.getElementById('detail-range').addEventListener('input', updateAction);
            document.getElementById('turbidity-range').addEventListener('input', () => {
                if(gemstone) gemstone.material.uniforms.uTurbidity.value = parseFloat(document.getElementById('turbidity-range').value);
            });
            document.getElementById('color-picker').addEventListener('input', () => {
                const val = document.getElementById('color-picker').value;
                if(gemstone) gemstone.material.uniforms.uColor.value.set(val);
            });
        }

        function setupInertiaEvents(container) {
            const onDown = (e) => { isDragging = true; previousMouseX = e.clientX || e.touches?.[0].clientX; };
            const onMove = (e) => {
                if (!isDragging) return;
                const x = e.clientX || e.touches?.[0].clientX;
                rotationVelocity = (x - previousMouseX) * 0.008;
                previousMouseX = x;
            };
            const onUp = () => isDragging = false;
            container.addEventListener('mousedown', onDown);
            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onUp);
            container.addEventListener('touchstart', onDown);
            window.addEventListener('touchmove', onMove);
            window.addEventListener('touchend', onUp);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            
            if (gemstone) {
                if (!isDragging) {
                    rotationVelocity *= damping;
                    if (Math.abs(rotationVelocity) < baseAutoRotation) {
                        rotationVelocity = Math.sign(rotationVelocity) * baseAutoRotation || baseAutoRotation;
                    }
                }
                gemstone.rotation.y += rotationVelocity;
                gemstone.material.uniforms.uTime.value = time;
                gemstone.material.uniforms.uLightPos.value.set(Math.sin(time*2)*5, 5, Math.cos(time*2)*5);
                gemstone.position.y = Math.sin(time * 0.4) * 0.05;
            }

            if (camera && renderer) {
                controls.update();
                renderer.render(scene, camera);
            }
        }

        window.addEventListener('resize', () => {
            if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>